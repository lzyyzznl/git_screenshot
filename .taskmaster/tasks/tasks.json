{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize WXT Project Structure",
        "description": "Set up the initial project structure using WXT framework with Vue 3, Element Plus, and UnoCSS integration.",
        "details": "Create a new project using WXT CLI:\n1. Install WXT globally: `npm install -g wxt`\n2. Initialize project: `wxt init browser-screen-recorder`\n3. Configure Vue 3 with Composition API: `npm install vue@latest`\n4. Add Element Plus: `npm install element-plus`\n5. Set up UnoCSS: `npm install -D unocss`\n6. Configure TypeScript support\n7. Set up project folders structure:\n   - `/popup` - For popup UI\n   - `/content` - For content scripts\n   - `/background` - For background scripts\n   - `/components` - For shared Vue components\n   - `/composables` - For shared Vue composables\n   - `/utils` - For utility functions\n8. Configure WXT manifest entries in `wxt.config.ts`\n<info added on 2025-06-28T16:59:19.370Z>\n## Task Completion Status\n\nThe WXT project structure has been successfully initialized with all required components:\n\n✅ Vue 3 has been configured (was already included in the project)\n✅ Element Plus UI library has been installed and integrated\n✅ UnoCSS atomic CSS engine has been installed and configured\n✅ WXT configuration file has been updated with necessary modules and permissions\n✅ Project directory structure created: composables/, utils/, types/\n✅ Updated popup component using Element Plus components and UnoCSS styles\n✅ Development server successfully started and running\n\n## Technical Implementation Details\n\n- Installed packages: element-plus, @unocss/runtime, unocss, @wxt-dev/unocss\n- Configured uno.config.ts file with presets, themes, and shortcuts\n- Updated wxt.config.ts with required permissions for screen recording\n- Popup component now displays complete recording interface including recording mode selection and parameter configuration options\n\nThe project foundation is now ready for the next development task.\n</info added on 2025-06-28T16:59:19.370Z>",
        "testStrategy": "Verify project structure is correctly set up by running `npm run dev` and ensuring the development server starts without errors. Check that Vue 3, Element Plus, and UnoCSS are properly integrated by creating a simple test component.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Popup UI Layout",
        "description": "Create the popup interface with recording mode selection, parameter configuration, and start recording button.",
        "details": "1. Create Vue component for popup UI using Composition API\n2. Implement layout sections as described in PRD:\n   - Title bar with plugin name\n   - Recording mode selection (screen, tab, region) using Element Plus radio buttons\n   - Recording parameters section with dropdowns for resolution (1080p/720p/480p) and frame rate (30fps/24fps/20fps)\n   - Audio toggle switch\n   - Prominent 'Start Recording' button\n   - Keyboard shortcut hint at bottom (Ctrl+Shift+E)\n3. Use UnoCSS for styling with atomic classes\n4. Implement responsive design for different popup sizes\n5. Store user preferences in browser storage\n\nExample structure:\n```vue\n<template>\n  <div class=\"p-4 w-80\">\n    <h1 class=\"text-xl font-bold mb-4 text-center\">录屏助手</h1>\n    \n    <el-form>\n      <el-form-item label=\"录制模式\">\n        <el-radio-group v-model=\"recordingMode\">\n          <el-radio label=\"screen\">屏幕录制</el-radio>\n          <el-radio label=\"tab\">标签页录制</el-radio>\n          <el-radio label=\"region\">区域录制</el-radio>\n        </el-radio-group>\n      </el-form-item>\n      \n      <!-- Resolution, frame rate, audio controls -->\n      \n      <el-button type=\"primary\" @click=\"startRecording\" class=\"w-full mt-4\">开始录制</el-button>\n    </el-form>\n    \n    <div class=\"text-xs text-gray-500 mt-4\">结束录制快捷键：Ctrl+Shift+E</div>\n  </div>\n</template>\n```\n<info added on 2025-06-28T17:00:51.863Z>\n## Task Completion Report\n\n### Completed Features\n1. Created complete popup UI layout with dimensions 380×580px\n2. Implemented title bar with icon and plugin name \"录屏助手\"\n3. Implemented recording mode selection area:\n   - Screen recording (with monitor icon)\n   - Tab recording (with tab icon)\n   - Region recording (with crop frame icon)\n4. Implemented recording parameter configuration area:\n   - Resolution selection: 1080p/720p/480p (with aspect ratio icon)\n   - Frame rate selection: 30fps(recommended)/24fps/20fps (with speedometer icon)\n   - Audio recording toggle (with microphone icon)\n5. Implemented start recording button with loading state and recording icon\n6. Added keyboard shortcut hint area (Ctrl+Shift+E)\n7. Used UnoCSS for atomic CSS style management\n8. Integrated Element Plus UI component library\n9. Implemented user preference storage functionality, auto-saving to browser storage\n10. Added communication mechanism with background script\n11. Implemented responsive design and icon system\n\n### Technical Implementation\n- Used Vue 3 Composition API\n- Element Plus components: el-radio-group, el-select, el-switch, el-button\n- UnoCSS classes: flex, grid, padding, margin, colors, etc.\n- Browser APIs: browser.storage.local, browser.runtime.sendMessage\n- Material Design icons: i-mdi-* series icons\n\n### UI Features\n- Modern flat design style\n- Consistent spacing and typography\n- Icon-enhanced visual effects\n- Clear information hierarchy\n- Smooth interaction feedback\n</info added on 2025-06-28T17:00:51.863Z>",
        "testStrategy": "Test the popup UI by manually verifying all UI elements render correctly. Ensure form controls work as expected and maintain state. Test responsiveness by resizing the popup window. Verify that Element Plus components are styled consistently with UnoCSS.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement Background Script for State Management",
        "description": "Create the background script to manage global state, handle cross-tab communication, and process permission requests.",
        "details": "1. Create background script entry point in WXT\n2. Implement state management for recording status using Vue's reactive system\n3. Set up message passing between popup, content scripts, and result page\n4. Handle browser permissions requests for screen capture and audio\n5. Implement session recovery mechanism for crash recovery\n6. Create storage utilities for saving recording preferences\n\nExample implementation:\n```ts\nimport { defineBackground } from 'wxt/background'\nimport { ref, reactive } from 'vue'\n\nexport default defineBackground({\n  setup() {\n    const recordingState = reactive({\n      isRecording: false,\n      mode: null, // 'screen', 'tab', or 'region'\n      startTime: null,\n      duration: 0,\n      fileSize: 0,\n      settings: {\n        resolution: '720p',\n        frameRate: 30,\n        audio: false\n      }\n    })\n\n    // Handle messages from popup and content scripts\n    browser.runtime.onMessage.addListener((message, sender, sendResponse) => {\n      if (message.type === 'START_RECORDING') {\n        // Request permissions and start recording\n        // Update recordingState\n      } else if (message.type === 'STOP_RECORDING') {\n        // Stop recording and process video\n      }\n      // Other message handlers\n    })\n\n    // Implement auto-recovery from local storage\n    function recoverSession() {\n      // Load saved state from storage and restore if needed\n    }\n\n    recoverSession()\n  }\n})\n```\n<info added on 2025-06-28T17:03:39.918Z>\n## Implementation Complete\n\nThe background script for state management has been successfully implemented with the following features:\n\n1. Complete background script state management system using Vue 3's reactive system\n2. Cross-component message handling:\n   - startRecording\n   - stopRecording\n   - pauseRecording/resumeRecording\n   - getRecordingState\n   - updateSettings\n3. Permission request handling (activeTab, desktopCapture, storage, scripting)\n4. Session recovery mechanism for browser crash recovery\n5. Storage utilities for saving recording preferences and states\n6. Tab management functionality\n7. MediaRecorder API integration:\n   - Multiple recording modes (screen/tab/area)\n   - Multiple resolution options (1080p/720p/480p)\n   - Configurable frame rates (30/24/20 fps)\n   - Audio recording toggle\n8. Recording data processing and storage\n9. Cross-tab notification system\n\nTechnical implementation details:\n- Vue 3 reactive() for global state management\n- TypeScript type-safe interfaces\n- MediaRecorder API for recording functionality\n- getDisplayMedia API for screen capture\n- browser.storage.local for persistent storage\n- browser.runtime.onMessage for message communication\n- browser.permissions API for permission management\n- browser.tabs API for tab management\n\nKey features:\n- Complete recording lifecycle management (start/pause/resume/stop)\n- Automatic permission checking and requesting\n- Crash recovery and session cleanup\n- Real-time state synchronization\n- Cross-tab state broadcasting\n- Automatic recording data saving and processing\n\nThe background script is now fully ready to work with the popup interface.\n</info added on 2025-06-28T17:03:39.918Z>",
        "testStrategy": "Test background script functionality by sending test messages from popup and content scripts. Verify state management by checking if recording state is properly maintained and updated. Test permission handling by simulating permission requests and responses. Verify session recovery by simulating a browser restart.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Screen Capture Functionality",
        "description": "Implement the core screen capture functionality using getDisplayMedia API to support different recording modes.",
        "details": "1. Create a utility module for screen capture\n2. Implement functions for each recording mode:\n   - Screen recording: Capture entire screen\n   - Tab recording: Capture current tab\n   - Region recording: Allow user to select a specific region\n3. Use MediaStream API and getDisplayMedia for capture\n4. Handle permission requests and denials gracefully\n5. Implement audio capture toggle functionality\n\nExample implementation:\n```ts\nexport async function startCapture(mode: 'screen' | 'tab' | 'region', withAudio: boolean) {\n  try {\n    const displayMediaOptions: DisplayMediaStreamOptions = {\n      video: {\n        cursor: 'always'\n      },\n      audio: withAudio ? {\n        echoCancellation: true,\n        noiseSuppression: true\n      } : false\n    };\n\n    // For region selection, adjust constraints\n    if (mode === 'region') {\n      displayMediaOptions.video = {\n        ...displayMediaOptions.video,\n        displaySurface: 'monitor',\n      };\n    } else if (mode === 'tab') {\n      displayMediaOptions.video = {\n        ...displayMediaOptions.video,\n        displaySurface: 'browser',\n      };\n    }\n\n    const stream = await navigator.mediaDevices.getDisplayMedia(displayMediaOptions);\n    return stream;\n  } catch (err) {\n    console.error('Error capturing screen:', err);\n    throw err;\n  }\n}\n```\n<info added on 2025-06-28T17:06:52.343Z>\n# Task Completion Report\n\n## Completed Items\n1. Created comprehensive screen capture utility module `utils/screenCapture.ts`\n2. Implemented support for three recording modes:\n   - Screen recording: Captures entire screen\n   - Tab recording: Captures current tab\n   - Region recording: Allows user to select specific region\n3. Used MediaStream API and getDisplayMedia for capture\n4. Implemented graceful permission request and denial handling\n5. Implemented audio capture toggle functionality\n6. Created professional error handling system:\n   - ScreenCaptureError custom error class\n   - Detailed error categorization (permission denied, unsupported, capture failure, etc.)\n7. Implemented capture support checking functionality\n8. Provided resolution and frame rate option management\n9. Implemented stream status monitoring and automatic cleanup\n10. Integrated into background scripts, replacing the original simple implementation\n\n## Core Features\n- `startCapture()`: Initiates screen capture with multiple configuration options\n- `stopCapture()`: Stops capture and cleans up resources\n- `checkCaptureSupport()`: Checks browser support\n- `getAvailableResolutions()`: Retrieves available resolution options\n- `getAvailableFrameRates()`: Retrieves available frame rate options\n- `getStreamInfo()`: Gets detailed stream information\n- `watchStreamStatus()`: Monitors stream status changes\n\n## Technical Implementation Details\n- TypeScript type-safe interface definitions\n- Optimized DisplayMediaStreamOptions configuration\n- Cursor capture support\n- Audio echo cancellation and noise suppression\n- Automatic gain control\n- Stream status event listening\n- Memory leak protection\n\n## Error Handling Mechanism\n- Browser compatibility checking\n- Permission status handling\n- Device availability verification\n- Configuration support detection\n- Unknown error wrapping\n\n## Integration Improvements\n- Updated background scripts to use the new capture utility\n- Added automatic stream status monitoring\n- Improved error propagation and handling\n- Enhanced information feedback when recording starts\n</info added on 2025-06-28T17:06:52.343Z>",
        "testStrategy": "Test screen capture functionality by implementing a simple test page that calls the capture functions. Verify each recording mode works correctly. Test audio capture by checking if audio tracks are included in the MediaStream when enabled. Test error handling by simulating permission denials.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement MediaRecorder for Video Processing",
        "description": "Create the MediaRecorder implementation to convert captured media streams into video data with configurable quality settings.",
        "details": "1. Create a recording service module\n2. Implement MediaRecorder setup with configurable options\n3. Add support for different resolutions and frame rates\n4. Implement chunked recording to manage memory usage\n5. Set up data collection and storage mechanism\n\nExample implementation:\n```ts\nexport class RecordingService {\n  private mediaRecorder: MediaRecorder | null = null;\n  private recordedChunks: Blob[] = [];\n  private stream: MediaStream | null = null;\n  \n  async startRecording(stream: MediaStream, options: {\n    mimeType?: string;\n    videoBitsPerSecond?: number;\n    frameRate?: number;\n  } = {}) {\n    this.stream = stream;\n    this.recordedChunks = [];\n    \n    // Apply frame rate constraint if specified\n    if (options.frameRate) {\n      this.stream.getVideoTracks().forEach(track => {\n        const settings = track.getSettings();\n        track.applyConstraints({\n          frameRate: options.frameRate\n        });\n      });\n    }\n    \n    // Set up MediaRecorder with options\n    const mediaRecorderOptions: MediaRecorderOptions = {\n      mimeType: options.mimeType || 'video/webm;codecs=vp9',\n      videoBitsPerSecond: options.videoBitsPerSecond || 2500000\n    };\n    \n    this.mediaRecorder = new MediaRecorder(this.stream, mediaRecorderOptions);\n    \n    // Set up event handlers\n    this.mediaRecorder.ondataavailable = (event) => {\n      if (event.data.size > 0) {\n        this.recordedChunks.push(event.data);\n        // Periodically save chunks to avoid memory issues\n        if (this.recordedChunks.length > 10) {\n          this.saveChunksToTemporaryStorage();\n        }\n      }\n    };\n    \n    // Start recording with 1-second chunks\n    this.mediaRecorder.start(1000);\n    return this.mediaRecorder;\n  }\n  \n  stopRecording(): Promise<Blob> {\n    return new Promise((resolve) => {\n      if (!this.mediaRecorder) {\n        resolve(new Blob());\n        return;\n      }\n      \n      this.mediaRecorder.onstop = () => {\n        const finalBlob = new Blob(this.recordedChunks, { type: 'video/webm' });\n        this.cleanUp();\n        resolve(finalBlob);\n      };\n      \n      this.mediaRecorder.stop();\n    });\n  }\n  \n  private saveChunksToTemporaryStorage() {\n    // Implement chunk storage to IndexedDB or other storage\n  }\n  \n  private cleanUp() {\n    if (this.stream) {\n      this.stream.getTracks().forEach(track => track.stop());\n      this.stream = null;\n    }\n    this.mediaRecorder = null;\n  }\n}\n```",
        "testStrategy": "Test MediaRecorder functionality by creating a test harness that captures a stream and records it. Verify different quality settings work correctly. Test memory management by recording for extended periods and monitoring memory usage. Verify that recorded video matches the specified resolution and frame rate.",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Recording Overlay UI",
        "description": "Create the floating toolbar overlay that appears during recording, providing drawing tools and recording controls.",
        "details": "1. Create a Vue component for the recording overlay\n2. Implement the toolbar layout with recording status, drawing tools, color picker, undo/redo buttons, and stop recording button\n3. Position the toolbar at the top of the screen using fixed positioning\n4. Implement toolbar visibility toggle\n5. Add recording timer and file size display\n\nExample implementation:\n```vue\n<template>\n  <div class=\"fixed top-2 left-1/2 transform -translate-x-1/2 bg-white rounded-lg shadow-md p-2 flex items-center z-50\">\n    <!-- Recording status indicator -->\n    <div class=\"flex items-center mr-4\">\n      <div class=\"w-3 h-3 rounded-full bg-red-500 animate-pulse mr-2\"></div>\n      <span class=\"text-sm\">{{ formattedDuration }}</span>\n      <span class=\"text-sm ml-2\">{{ formattedFileSize }}</span>\n    </div>\n    \n    <!-- Drawing tools -->\n    <div class=\"flex items-center space-x-1 mr-4\">\n      <el-button-group>\n        <el-button :type=\"currentTool === 'pencil' ? 'primary' : 'default'\" @click=\"setTool('pencil')\" size=\"small\">\n          <i class=\"i-carbon-pen\"></i>\n        </el-button>\n        <el-button :type=\"currentTool === 'highlighter' ? 'primary' : 'default'\" @click=\"setTool('highlighter')\" size=\"small\">\n          <i class=\"i-carbon-text-highlight\"></i>\n        </el-button>\n        <el-button :type=\"currentTool === 'eraser' ? 'primary' : 'default'\" @click=\"setTool('eraser')\" size=\"small\">\n          <i class=\"i-carbon-erase\"></i>\n        </el-button>\n      </el-button-group>\n    </div>\n    \n    <!-- Color picker -->\n    <el-color-picker v-model=\"currentColor\" size=\"small\" class=\"mr-4\" :disabled=\"currentTool === 'eraser'\"></el-color-picker>\n    \n    <!-- Undo/Redo buttons -->\n    <div class=\"flex items-center space-x-1 mr-4\">\n      <el-button :disabled=\"!canUndo\" @click=\"undo\" size=\"small\">\n        <i class=\"i-carbon-undo\"></i>\n      </el-button>\n      <el-button :disabled=\"!canRedo\" @click=\"redo\" size=\"small\">\n        <i class=\"i-carbon-redo\"></i>\n      </el-button>\n    </div>\n    \n    <!-- Stop recording button -->\n    <el-button type=\"danger\" @click=\"stopRecording\" size=\"small\">\n      结束录制\n    </el-button>\n  </div>\n</template>\n```",
        "testStrategy": "Test the recording overlay by manually verifying it appears correctly during recording. Check that all buttons and controls are functional. Test the timer display by recording for different durations. Verify the toolbar is properly positioned and doesn't interfere with the content being recorded.",
        "priority": "medium",
        "dependencies": [
          2,
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Drawing Canvas Functionality",
        "description": "Create the canvas-based drawing system that allows users to annotate the screen during recording.",
        "details": "1. Create a canvas overlay that covers the entire viewport\n2. Implement drawing tools: pencil, highlighter, and eraser\n3. Add color selection functionality\n4. Implement undo/redo stack for drawing operations\n5. Optimize canvas performance using requestAnimationFrame\n6. Implement off-screen rendering for better performance\n\nExample implementation:\n```ts\nexport class DrawingCanvas {\n  private canvas: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n  private isDrawing = false;\n  private lastX = 0;\n  private lastY = 0;\n  private history: ImageData[] = [];\n  private redoStack: ImageData[] = [];\n  private currentTool: 'pencil' | 'highlighter' | 'eraser' = 'pencil';\n  private currentColor = '#FF0000';\n  \n  constructor() {\n    this.canvas = document.createElement('canvas');\n    this.canvas.width = window.innerWidth;\n    this.canvas.height = window.innerHeight;\n    this.canvas.style.position = 'fixed';\n    this.canvas.style.top = '0';\n    this.canvas.style.left = '0';\n    this.canvas.style.zIndex = '9999';\n    this.canvas.style.pointerEvents = 'none'; // Allow clicks to pass through\n    \n    const ctx = this.canvas.getContext('2d');\n    if (!ctx) throw new Error('Could not get canvas context');\n    this.ctx = ctx;\n    \n    // Save initial state\n    this.saveState();\n    \n    // Handle window resize\n    window.addEventListener('resize', this.handleResize.bind(this));\n  }\n  \n  mount() {\n    document.body.appendChild(this.canvas);\n    this.setupEventListeners();\n  }\n  \n  unmount() {\n    document.body.removeChild(this.canvas);\n    this.removeEventListeners();\n  }\n  \n  setTool(tool: 'pencil' | 'highlighter' | 'eraser') {\n    this.currentTool = tool;\n  }\n  \n  setColor(color: string) {\n    this.currentColor = color;\n  }\n  \n  undo() {\n    if (this.history.length <= 1) return false;\n    \n    // Save current state to redo stack\n    const currentState = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\n    this.redoStack.push(currentState);\n    \n    // Pop the current state and get the previous one\n    this.history.pop();\n    const previousState = this.history[this.history.length - 1];\n    \n    // Restore previous state\n    this.ctx.putImageData(previousState, 0, 0);\n    return true;\n  }\n  \n  redo() {\n    if (this.redoStack.length === 0) return false;\n    \n    // Get the last redo state\n    const redoState = this.redoStack.pop()!;\n    \n    // Save current state to history\n    const currentState = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\n    this.history.push(currentState);\n    \n    // Apply redo state\n    this.ctx.putImageData(redoState, 0, 0);\n    return true;\n  }\n  \n  private setupEventListeners() {\n    this.canvas.style.pointerEvents = 'auto';\n    this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));\n    this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));\n    this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));\n    this.canvas.addEventListener('mouseout', this.handleMouseUp.bind(this));\n  }\n  \n  private removeEventListeners() {\n    this.canvas.removeEventListener('mousedown', this.handleMouseDown.bind(this));\n    this.canvas.removeEventListener('mousemove', this.handleMouseMove.bind(this));\n    this.canvas.removeEventListener('mouseup', this.handleMouseUp.bind(this));\n    this.canvas.removeEventListener('mouseout', this.handleMouseUp.bind(this));\n  }\n  \n  private handleMouseDown(e: MouseEvent) {\n    this.isDrawing = true;\n    this.lastX = e.clientX;\n    this.lastY = e.clientY;\n  }\n  \n  private handleMouseMove(e: MouseEvent) {\n    if (!this.isDrawing) return;\n    \n    requestAnimationFrame(() => {\n      this.draw(e.clientX, e.clientY);\n    });\n  }\n  \n  private handleMouseUp() {\n    if (this.isDrawing) {\n      this.isDrawing = false;\n      this.saveState();\n    }\n  }\n  \n  private draw(x: number, y: number) {\n    this.ctx.beginPath();\n    this.ctx.moveTo(this.lastX, this.lastY);\n    this.ctx.lineTo(x, y);\n    \n    switch (this.currentTool) {\n      case 'pencil':\n        this.ctx.globalCompositeOperation = 'source-over';\n        this.ctx.strokeStyle = this.currentColor;\n        this.ctx.lineWidth = 2;\n        this.ctx.lineCap = 'round';\n        this.ctx.lineJoin = 'round';\n        break;\n      case 'highlighter':\n        this.ctx.globalCompositeOperation = 'source-over';\n        this.ctx.strokeStyle = this.currentColor + '80'; // Add transparency\n        this.ctx.lineWidth = 10;\n        this.ctx.lineCap = 'square';\n        this.ctx.lineJoin = 'round';\n        break;\n      case 'eraser':\n        this.ctx.globalCompositeOperation = 'destination-out';\n        this.ctx.strokeStyle = 'rgba(0,0,0,1)';\n        this.ctx.lineWidth = 20;\n        this.ctx.lineCap = 'round';\n        this.ctx.lineJoin = 'round';\n        break;\n    }\n    \n    this.ctx.stroke();\n    this.ctx.closePath();\n    \n    this.lastX = x;\n    this.lastY = y;\n  }\n  \n  private saveState() {\n    const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\n    this.history.push(imageData);\n    this.redoStack = []; // Clear redo stack when new action is performed\n  }\n  \n  private handleResize() {\n    // Save current drawing\n    const tempCanvas = document.createElement('canvas');\n    tempCanvas.width = this.canvas.width;\n    tempCanvas.height = this.canvas.height;\n    const tempCtx = tempCanvas.getContext('2d');\n    if (tempCtx) {\n      tempCtx.drawImage(this.canvas, 0, 0);\n    }\n    \n    // Resize canvas\n    this.canvas.width = window.innerWidth;\n    this.canvas.height = window.innerHeight;\n    \n    // Restore drawing\n    this.ctx.drawImage(tempCanvas, 0, 0);\n    \n    // Update history\n    this.saveState();\n  }\n}\n```",
        "testStrategy": "Test drawing functionality by creating a test page with the canvas overlay. Verify each drawing tool works correctly. Test undo/redo functionality by performing a series of drawing operations and undoing/redoing them. Test performance by drawing rapidly and checking for lag. Verify canvas resizing works correctly when the window is resized.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Result Page UI",
        "description": "Create the result page that displays after recording is complete, allowing users to preview, edit, and download the recording.",
        "details": "1. Create a new tab page for displaying recording results\n2. Implement video player with controls\n3. Add download buttons for MP4 format\n4. Add GIF conversion functionality with quality settings\n5. Implement progress indicators for conversion processes\n6. Add re-edit option to add annotations to the recorded video\n\nExample implementation:\n```vue\n<template>\n  <div class=\"container mx-auto p-6 max-w-4xl\">\n    <h1 class=\"text-2xl font-bold mb-6 text-center\">录制完成</h1>\n    \n    <!-- Video preview -->\n    <div class=\"relative mb-6 bg-gray-100 rounded-lg overflow-hidden\">\n      <video ref=\"videoPlayer\" controls class=\"w-full h-auto\">\n        <source :src=\"videoUrl\" type=\"video/webm\">\n      </video>\n      <canvas v-if=\"isEditing\" ref=\"annotationCanvas\" class=\"absolute top-0 left-0 w-full h-full pointer-events-auto\"></canvas>\n    </div>\n    \n    <!-- Action buttons -->\n    <div class=\"flex flex-wrap gap-4 justify-center mb-6\">\n      <el-button type=\"primary\" @click=\"downloadMP4\">\n        <i class=\"i-carbon-download mr-1\"></i> 下载 MP4\n      </el-button>\n      <el-button type=\"success\" @click=\"showGifSettings = !showGifSettings\">\n        <i class=\"i-carbon-image mr-1\"></i> 转换 GIF\n      </el-button>\n      <el-button @click=\"toggleEditing\">\n        <i class=\"i-carbon-edit mr-1\"></i> {{ isEditing ? '完成编辑' : '重新编辑' }}\n      </el-button>\n    </div>\n    \n    <!-- GIF conversion settings -->\n    <el-collapse-transition>\n      <div v-if=\"showGifSettings\" class=\"mb-6 p-4 border rounded-lg\">\n        <h3 class=\"text-lg font-medium mb-4\">GIF 转换设置</h3>\n        \n        <el-form>\n          <el-form-item label=\"质量\">\n            <el-radio-group v-model=\"gifQuality\">\n              <el-radio label=\"high\">高</el-radio>\n              <el-radio label=\"medium\">中</el-radio>\n              <el-radio label=\"low\">低</el-radio>\n            </el-radio-group>\n          </el-form-item>\n          \n          <el-form-item label=\"帧率\">\n            <el-slider v-model=\"gifFrameRate\" :min=\"10\" :max=\"30\" :step=\"1\" show-input></el-slider>\n          </el-form-item>\n          \n          <el-button type=\"primary\" @click=\"convertToGif\" :loading=\"isConverting\">\n            开始转换\n          </el-button>\n        </el-form>\n      </div>\n    </el-collapse-transition>\n    \n    <!-- Progress indicator -->\n    <div v-if=\"conversionProgress > 0 && conversionProgress < 100\" class=\"mb-6\">\n      <el-progress :percentage=\"conversionProgress\" :status=\"conversionStatus\"></el-progress>\n      <p class=\"text-center text-sm text-gray-500 mt-2\">{{ progressMessage }}</p>\n    </div>\n  </div>\n</template>\n```",
        "testStrategy": "Test the result page by loading it with a test video. Verify the video player works correctly. Test the download functionality by downloading the video in MP4 format. Test GIF conversion with different quality settings. Verify progress indicators update correctly during conversion. Test the re-edit functionality by adding annotations to the video.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Video Format Conversion",
        "description": "Create the functionality to convert recorded videos to different formats, particularly WebM to MP4 and GIF.",
        "details": "1. Implement WebM to MP4 conversion using Web Workers\n2. Create GIF conversion functionality with configurable quality and frame rate\n3. Add progress tracking for conversion processes\n4. Implement error handling for conversion failures\n5. Optimize conversion for performance\n\nExample implementation:\n```ts\nexport class VideoConverter {\n  // Convert WebM to MP4 using a Web Worker\n  convertToMP4(webmBlob: Blob, onProgress?: (progress: number) => void): Promise<Blob> {\n    return new Promise((resolve, reject) => {\n      const worker = new Worker(new URL('./conversion-worker.ts', import.meta.url));\n      \n      worker.onmessage = (e) => {\n        if (e.data.type === 'progress') {\n          onProgress?.(e.data.progress);\n        } else if (e.data.type === 'complete') {\n          resolve(e.data.result);\n          worker.terminate();\n        } else if (e.data.type === 'error') {\n          reject(new Error(e.data.message));\n          worker.terminate();\n        }\n      };\n      \n      worker.postMessage({\n        type: 'convertToMP4',\n        blob: webmBlob\n      });\n    });\n  }\n  \n  // Convert video to GIF with quality settings\n  convertToGIF(videoBlob: Blob, options: {\n    frameRate?: number;\n    quality?: 'high' | 'medium' | 'low';\n    onProgress?: (progress: number) => void;\n  } = {}): Promise<Blob> {\n    return new Promise((resolve, reject) => {\n      const worker = new Worker(new URL('./gif-worker.ts', import.meta.url));\n      \n      worker.onmessage = (e) => {\n        if (e.data.type === 'progress') {\n          options.onProgress?.(e.data.progress);\n        } else if (e.data.type === 'complete') {\n          resolve(e.data.result);\n          worker.terminate();\n        } else if (e.data.type === 'error') {\n          reject(new Error(e.data.message));\n          worker.terminate();\n        }\n      };\n      \n      // Create video element to extract frames\n      const video = document.createElement('video');\n      video.muted = true;\n      video.autoplay = false;\n      video.src = URL.createObjectURL(videoBlob);\n      \n      video.onloadedmetadata = () => {\n        // Get video dimensions and duration\n        const duration = video.duration;\n        const width = video.videoWidth;\n        const height = video.videoHeight;\n        \n        // Calculate quality settings\n        let gifQuality = 10; // Default medium quality\n        switch (options.quality) {\n          case 'high': gifQuality = 1; break;\n          case 'medium': gifQuality = 10; break;\n          case 'low': gifQuality = 20; break;\n        }\n        \n        worker.postMessage({\n          type: 'convertToGIF',\n          blob: videoBlob,\n          frameRate: options.frameRate || 15,\n          quality: gifQuality,\n          width,\n          height,\n          duration\n        });\n        \n        URL.revokeObjectURL(video.src);\n      };\n      \n      video.onerror = () => {\n        reject(new Error('Failed to load video for GIF conversion'));\n        URL.revokeObjectURL(video.src);\n      };\n    });\n  }\n}\n```",
        "testStrategy": "Test video conversion by converting sample videos to MP4 and GIF formats. Verify the quality of the converted videos. Test with different quality settings and frame rates. Measure conversion time and optimize if necessary. Test error handling by providing invalid inputs.",
        "priority": "medium",
        "dependencies": [
          5,
          8
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Keyboard Shortcuts",
        "description": "Add keyboard shortcut support for controlling the recording process and drawing tools.",
        "details": "1. Implement keyboard shortcut listener in content script\n2. Add shortcut for stopping recording (Ctrl+Shift+E)\n3. Add shortcuts for switching between drawing tools\n4. Add shortcuts for undo/redo operations\n5. Implement shortcut help overlay\n\nExample implementation:\n```ts\nexport class KeyboardShortcutManager {\n  private shortcuts: Map<string, () => void> = new Map();\n  private enabled = false;\n  \n  constructor() {\n    this.handleKeyDown = this.handleKeyDown.bind(this);\n  }\n  \n  registerShortcut(key: string, callback: () => void) {\n    this.shortcuts.set(key.toLowerCase(), callback);\n  }\n  \n  unregisterShortcut(key: string) {\n    this.shortcuts.delete(key.toLowerCase());\n  }\n  \n  enable() {\n    if (!this.enabled) {\n      document.addEventListener('keydown', this.handleKeyDown);\n      this.enabled = true;\n    }\n  }\n  \n  disable() {\n    if (this.enabled) {\n      document.removeEventListener('keydown', this.handleKeyDown);\n      this.enabled = false;\n    }\n  }\n  \n  private handleKeyDown(event: KeyboardEvent) {\n    // Build key combination string (e.g., 'ctrl+shift+e')\n    const key = [];\n    if (event.ctrlKey) key.push('ctrl');\n    if (event.shiftKey) key.push('shift');\n    if (event.altKey) key.push('alt');\n    if (event.key !== 'Control' && event.key !== 'Shift' && event.key !== 'Alt') {\n      key.push(event.key.toLowerCase());\n    }\n    \n    const keyCombo = key.join('+');\n    \n    // Check if this key combination is registered\n    const callback = this.shortcuts.get(keyCombo);\n    if (callback) {\n      event.preventDefault();\n      callback();\n    }\n  }\n}\n\n// Usage example\nconst shortcutManager = new KeyboardShortcutManager();\n\n// Register shortcuts\nshortcutManager.registerShortcut('ctrl+shift+e', () => {\n  // Stop recording\n});\nshortcutManager.registerShortcut('p', () => {\n  // Switch to pencil tool\n});\nshortcutManager.registerShortcut('h', () => {\n  // Switch to highlighter tool\n});\nshortcutManager.registerShortcut('e', () => {\n  // Switch to eraser tool\n});\nshortcutManager.registerShortcut('ctrl+z', () => {\n  // Undo\n});\nshortcutManager.registerShortcut('ctrl+y', () => {\n  // Redo\n});\n\n// Enable shortcuts when recording starts\nshortcutManager.enable();\n```",
        "testStrategy": "Test keyboard shortcuts by simulating key presses and verifying the correct actions are triggered. Test combinations of modifier keys (Ctrl, Shift, Alt) with regular keys. Verify shortcuts work correctly in different contexts (during recording, while drawing, etc.). Test that shortcuts don't interfere with normal browser functionality when not recording.",
        "priority": "low",
        "dependencies": [
          6,
          7
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Implement Memory Management and Performance Optimization",
        "description": "Optimize the extension for memory usage and performance, especially for long recordings.",
        "details": "1. Implement chunked recording to manage memory usage\n2. Create a Web Worker for video processing tasks\n3. Implement periodic cleanup of temporary data\n4. Add dynamic quality adjustment based on system performance\n5. Optimize canvas rendering for drawing tools\n\nExample implementation:\n```ts\nexport class PerformanceManager {\n  private memoryThreshold = 100 * 1024 * 1024; // 100MB\n  private lastPerformanceCheck = 0;\n  private checkInterval = 5000; // 5 seconds\n  private recordingQuality: 'high' | 'medium' | 'low' = 'high';\n  private recordedChunks: Blob[] = [];\n  private totalSize = 0;\n  \n  // Monitor performance and adjust settings if needed\n  checkPerformance() {\n    const now = Date.now();\n    if (now - this.lastPerformanceCheck < this.checkInterval) return;\n    \n    this.lastPerformanceCheck = now;\n    \n    // Check memory usage if available\n    if (performance.memory) {\n      const usedHeap = performance.memory.usedJSHeapSize;\n      const heapLimit = performance.memory.jsHeapSizeLimit;\n      \n      // If memory usage is high, reduce quality\n      if (usedHeap > heapLimit * 0.7 && this.recordingQuality === 'high') {\n        this.recordingQuality = 'medium';\n        this.adjustRecordingQuality();\n      } else if (usedHeap > heapLimit * 0.85 && this.recordingQuality === 'medium') {\n        this.recordingQuality = 'low';\n        this.adjustRecordingQuality();\n      }\n    }\n    \n    // Check frame rate\n    const fps = this.measureFrameRate();\n    if (fps < 15 && this.recordingQuality === 'high') {\n      this.recordingQuality = 'medium';\n      this.adjustRecordingQuality();\n    } else if (fps < 10 && this.recordingQuality === 'medium') {\n      this.recordingQuality = 'low';\n      this.adjustRecordingQuality();\n    }\n  }\n  \n  // Add a chunk to storage and manage total size\n  addChunk(chunk: Blob) {\n    this.recordedChunks.push(chunk);\n    this.totalSize += chunk.size;\n    \n    // If total size exceeds threshold, store to IndexedDB\n    if (this.totalSize > this.memoryThreshold) {\n      this.storeChunksToIndexedDB();\n      this.recordedChunks = [];\n      this.totalSize = 0;\n    }\n  }\n  \n  // Store chunks to IndexedDB to free memory\n  private async storeChunksToIndexedDB() {\n    // Implementation of IndexedDB storage\n    const db = await this.openDatabase();\n    const transaction = db.transaction(['chunks'], 'readwrite');\n    const store = transaction.objectStore('chunks');\n    \n    const chunkBlob = new Blob(this.recordedChunks, { type: 'video/webm' });\n    const chunkId = Date.now().toString();\n    \n    await store.add({ id: chunkId, data: chunkBlob });\n  }\n  \n  // Retrieve all chunks from IndexedDB\n  async getAllChunks(): Promise<Blob[]> {\n    const db = await this.openDatabase();\n    const transaction = db.transaction(['chunks'], 'readonly');\n    const store = transaction.objectStore('chunks');\n    \n    return new Promise((resolve, reject) => {\n      const request = store.getAll();\n      \n      request.onsuccess = () => {\n        const chunks = request.result.map(item => item.data);\n        resolve([...chunks, ...this.recordedChunks]);\n      };\n      \n      request.onerror = () => {\n        reject(request.error);\n      };\n    });\n  }\n  \n  // Clear all stored chunks\n  async clearChunks() {\n    const db = await this.openDatabase();\n    const transaction = db.transaction(['chunks'], 'readwrite');\n    const store = transaction.objectStore('chunks');\n    \n    await store.clear();\n    this.recordedChunks = [];\n    this.totalSize = 0;\n  }\n  \n  // Open IndexedDB database\n  private openDatabase(): Promise<IDBDatabase> {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open('RecordingChunks', 1);\n      \n      request.onupgradeneeded = () => {\n        const db = request.result;\n        if (!db.objectStoreNames.contains('chunks')) {\n          db.createObjectStore('chunks', { keyPath: 'id' });\n        }\n      };\n      \n      request.onsuccess = () => {\n        resolve(request.result);\n      };\n      \n      request.onerror = () => {\n        reject(request.error);\n      };\n    });\n  }\n  \n  // Measure current frame rate\n  private measureFrameRate(): number {\n    // Implementation to measure frame rate\n    // This is a simplified example\n    return 30; // Default value\n  }\n  \n  // Adjust recording quality based on current setting\n  private adjustRecordingQuality() {\n    // Implementation to adjust MediaRecorder settings\n    // This would be called when quality changes\n  }\n}\n```",
        "testStrategy": "Test memory management by recording for extended periods and monitoring memory usage. Verify that chunked recording works correctly by checking if data is properly stored and retrieved. Test performance optimization by measuring frame rates during recording with different quality settings. Test dynamic quality adjustment by simulating low performance conditions.",
        "priority": "medium",
        "dependencies": [
          5,
          7,
          9
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement Error Handling and Recovery Mechanism",
        "description": "Create robust error handling and recovery mechanisms to handle crashes, permission denials, and other failure scenarios.",
        "details": "1. Implement global error handler for uncaught exceptions\n2. Create recovery mechanism for unexpected crashes\n3. Add graceful handling for permission denials\n4. Implement automatic saving of recording progress\n5. Add user-friendly error messages and recovery options\n\nExample implementation:\n```ts\nexport class ErrorHandler {\n  private static instance: ErrorHandler;\n  private recoveryData: any = null;\n  \n  private constructor() {\n    this.setupGlobalHandlers();\n  }\n  \n  static getInstance(): ErrorHandler {\n    if (!ErrorHandler.instance) {\n      ErrorHandler.instance = new ErrorHandler();\n    }\n    return ErrorHandler.instance;\n  }\n  \n  // Set up global error handlers\n  private setupGlobalHandlers() {\n    // Handle uncaught exceptions\n    window.addEventListener('error', this.handleGlobalError.bind(this));\n    \n    // Handle unhandled promise rejections\n    window.addEventListener('unhandledrejection', this.handleUnhandledRejection.bind(this));\n    \n    // Handle beforeunload to save state\n    window.addEventListener('beforeunload', this.saveStateBeforeUnload.bind(this));\n  }\n  \n  // Handle global errors\n  private handleGlobalError(event: ErrorEvent) {\n    console.error('Global error:', event.error);\n    this.saveRecoveryData();\n    this.showErrorNotification(event.error.message);\n    return false;\n  }\n  \n  // Handle unhandled promise rejections\n  private handleUnhandledRejection(event: PromiseRejectionEvent) {\n    console.error('Unhandled rejection:', event.reason);\n    this.saveRecoveryData();\n    this.showErrorNotification(event.reason.message || 'An error occurred');\n    return false;\n  }\n  \n  // Save state before page unload\n  private saveStateBeforeUnload() {\n    this.saveRecoveryData();\n  }\n  \n  // Handle permission errors\n  handlePermissionError(error: Error) {\n    console.error('Permission error:', error);\n    \n    // Show user-friendly message with instructions\n    this.showErrorNotification(\n      'Permission denied. Please allow screen recording permissions in your browser settings.',\n      [\n        {\n          text: 'How to fix',\n          action: () => this.showPermissionHelp()\n        },\n        {\n          text: 'Try again',\n          action: () => this.retryLastAction()\n        }\n      ]\n    );\n  }\n  \n  // Handle storage errors\n  handleStorageError(error: Error) {\n    console.error('Storage error:', error);\n    \n    // Check if it's a quota exceeded error\n    if (error.name === 'QuotaExceededError') {\n      this.showErrorNotification(\n        'Storage space exceeded. Try clearing browser data or reducing recording quality.',\n        [\n          {\n            text: 'Reduce quality',\n            action: () => this.reduceRecordingQuality()\n          },\n          {\n            text: 'Clear old recordings',\n            action: () => this.clearOldRecordings()\n          }\n        ]\n      );\n    } else {\n      this.showErrorNotification('Storage error: ' + error.message);\n    }\n  }\n  \n  // Save recovery data to local storage\n  saveRecoveryData() {\n    if (!this.recoveryData) return;\n    \n    try {\n      localStorage.setItem('recordingRecoveryData', JSON.stringify({\n        timestamp: Date.now(),\n        data: this.recoveryData\n      }));\n    } catch (err) {\n      console.error('Failed to save recovery data:', err);\n    }\n  }\n  \n  // Set current recovery data\n  setRecoveryData(data: any) {\n    this.recoveryData = data;\n    this.saveRecoveryData();\n  }\n  \n  // Check if there's recovery data available\n  hasRecoveryData(): boolean {\n    try {\n      const savedData = localStorage.getItem('recordingRecoveryData');\n      return !!savedData;\n    } catch (err) {\n      return false;\n    }\n  }\n  \n  // Get recovery data\n  getRecoveryData(): any {\n    try {\n      const savedData = localStorage.getItem('recordingRecoveryData');\n      if (!savedData) return null;\n      \n      const parsed = JSON.parse(savedData);\n      \n      // Check if data is too old (more than 1 hour)\n      if (Date.now() - parsed.timestamp > 60 * 60 * 1000) {\n        localStorage.removeItem('recordingRecoveryData');\n        return null;\n      }\n      \n      return parsed.data;\n    } catch (err) {\n      console.error('Failed to get recovery data:', err);\n      return null;\n    }\n  }\n  \n  // Clear recovery data\n  clearRecoveryData() {\n    this.recoveryData = null;\n    try {\n      localStorage.removeItem('recordingRecoveryData');\n    } catch (err) {\n      console.error('Failed to clear recovery data:', err);\n    }\n  }\n  \n  // Show error notification to user\n  private showErrorNotification(message: string, actions: Array<{text: string, action: () => void}> = []) {\n    // Implementation to show error notification\n    console.error('Error notification:', message);\n    // This would typically use Element Plus notification component\n  }\n  \n  // Show help for fixing permission issues\n  private showPermissionHelp() {\n    // Implementation to show permission help\n  }\n  \n  // Retry the last action that failed\n  private retryLastAction() {\n    // Implementation to retry last action\n  }\n  \n  // Reduce recording quality to handle storage issues\n  private reduceRecordingQuality() {\n    // Implementation to reduce quality\n  }\n  \n  // Clear old recordings to free up space\n  private clearOldRecordings() {\n    // Implementation to clear old recordings\n  }\n}\n```",
        "testStrategy": "Test error handling by simulating various error conditions such as permission denials, storage quota exceeded, and unexpected exceptions. Verify that recovery mechanisms work correctly by intentionally causing crashes and checking if state is properly recovered. Test user notifications by verifying error messages are displayed correctly and recovery options work as expected.",
        "priority": "medium",
        "dependencies": [
          3,
          5,
          11
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement Browser Compatibility Layer",
        "description": "Create a compatibility layer to ensure the extension works consistently across Chrome and Firefox browsers.",
        "details": "1. Create browser API wrappers to handle differences between Chrome and Firefox\n2. Implement feature detection for browser-specific capabilities\n3. Add fallbacks for unsupported features\n4. Test and fix browser-specific issues\n\nExample implementation:\n```ts\nexport class BrowserCompat {\n  // Check which browser we're running in\n  static getBrowserType(): 'chrome' | 'firefox' | 'other' {\n    if (navigator.userAgent.includes('Firefox')) {\n      return 'firefox';\n    } else if (navigator.userAgent.includes('Chrome')) {\n      return 'chrome';\n    } else {\n      return 'other';\n    }\n  }\n  \n  // Get browser-specific API object\n  static getBrowserAPI() {\n    return typeof chrome !== 'undefined' ? chrome : browser;\n  }\n  \n  // Check if a feature is supported\n  static isFeatureSupported(feature: string): boolean {\n    switch (feature) {\n      case 'getDisplayMedia':\n        return !!navigator.mediaDevices?.getDisplayMedia;\n      case 'mediaRecorder':\n        return typeof MediaRecorder !== 'undefined';\n      case 'webp':\n        return BrowserCompat.checkWebPSupport();\n      case 'indexedDB':\n        return !!window.indexedDB;\n      default:\n        return false;\n    }\n  }\n  \n  // Get supported MIME types for recording\n  static getSupportedMimeTypes(): string[] {\n    const types = [\n      'video/webm;codecs=vp9,opus',\n      'video/webm;codecs=vp8,opus',\n      'video/webm;codecs=h264,opus',\n      'video/webm',\n      'video/mp4'\n    ];\n    \n    return types.filter(type => MediaRecorder.isTypeSupported(type));\n  }\n  \n  // Get best supported MIME type\n  static getBestMimeType(): string {\n    const supported = BrowserCompat.getSupportedMimeTypes();\n    return supported[0] || 'video/webm';\n  }\n  \n  // Request permissions with browser-specific handling\n  static async requestPermissions(): Promise<boolean> {\n    try {\n      // For screen capture\n      if (navigator.mediaDevices?.getDisplayMedia) {\n        // Just check if we can request, don't actually request yet\n        return true;\n      }\n      \n      // For Firefox, we might need to check permissions differently\n      if (BrowserCompat.getBrowserType() === 'firefox') {\n        // Firefox-specific permission check\n      }\n      \n      return false;\n    } catch (err) {\n      console.error('Error checking permissions:', err);\n      return false;\n    }\n  }\n  \n  // Send message to background script with browser compatibility\n  static sendMessage(message: any): Promise<any> {\n    const browserAPI = BrowserCompat.getBrowserAPI();\n    \n    return new Promise((resolve, reject) => {\n      browserAPI.runtime.sendMessage(message, (response: any) => {\n        if (browserAPI.runtime.lastError) {\n          reject(browserAPI.runtime.lastError);\n        } else {\n          resolve(response);\n        }\n      });\n    });\n  }\n  \n  // Check WebP support\n  private static checkWebPSupport(): boolean {\n    const canvas = document.createElement('canvas');\n    if (canvas.getContext && canvas.getContext('2d')) {\n      // Check if toDataURL with WebP returns a WebP image\n      return canvas.toDataURL('image/webp').startsWith('data:image/webp');\n    }\n    return false;\n  }\n}\n```",
        "testStrategy": "Test browser compatibility by running the extension in both Chrome and Firefox. Verify that all features work correctly in both browsers. Test feature detection by simulating unsupported features and checking if fallbacks are used correctly. Test browser-specific APIs by ensuring they are properly wrapped and work consistently across browsers.",
        "priority": "medium",
        "dependencies": [
          1,
          3,
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Create Composable Hooks for Vue Components",
        "description": "Implement reusable Vue 3 composable hooks for common functionality across the extension.",
        "details": "1. Create composables for recording state management\n2. Implement hooks for drawing tools\n3. Create composables for video processing\n4. Implement hooks for error handling\n5. Create composables for browser API interactions\n\nExample implementation:\n```ts\n// useRecording.ts - Composable for recording functionality\nimport { ref, computed, onUnmounted } from 'vue';\nimport { RecordingService } from '../services/recording-service';\n\nexport function useRecording() {\n  const isRecording = ref(false);\n  const recordingMode = ref<'screen' | 'tab' | 'region'>('tab');\n  const recordingDuration = ref(0);\n  const recordingFileSize = ref(0);\n  const recordingService = new RecordingService();\n  let durationInterval: number | null = null;\n  \n  const formattedDuration = computed(() => {\n    const minutes = Math.floor(recordingDuration.value / 60);\n    const seconds = recordingDuration.value % 60;\n    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;\n  });\n  \n  const formattedFileSize = computed(() => {\n    if (recordingFileSize.value < 1024) {\n      return `${recordingFileSize.value}B`;\n    } else if (recordingFileSize.value < 1024 * 1024) {\n      return `${(recordingFileSize.value / 1024).toFixed(1)}KB`;\n    } else {\n      return `${(recordingFileSize.value / (1024 * 1024)).toFixed(1)}MB`;\n    }\n  });\n  \n  async function startRecording(options: {\n    mode: 'screen' | 'tab' | 'region';\n    audio: boolean;\n    resolution: string;\n    frameRate: number;\n  }) {\n    try {\n      recordingMode.value = options.mode;\n      await recordingService.startRecording(options);\n      isRecording.value = true;\n      recordingDuration.value = 0;\n      recordingFileSize.value = 0;\n      \n      // Start duration timer\n      durationInterval = window.setInterval(() => {\n        recordingDuration.value++;\n        // Update file size periodically\n        recordingFileSize.value = recordingService.getCurrentFileSize();\n      }, 1000);\n      \n      return true;\n    } catch (err) {\n      console.error('Failed to start recording:', err);\n      return false;\n    }\n  }\n  \n  async function stopRecording(): Promise<Blob | null> {\n    if (!isRecording.value) return null;\n    \n    try {\n      // Clear interval\n      if (durationInterval !== null) {\n        clearInterval(durationInterval);\n        durationInterval = null;\n      }\n      \n      const recordedBlob = await recordingService.stopRecording();\n      isRecording.value = false;\n      return recordedBlob;\n    } catch (err) {\n      console.error('Failed to stop recording:', err);\n      isRecording.value = false;\n      return null;\n    }\n  }\n  \n  // Clean up on component unmount\n  onUnmounted(() => {\n    if (durationInterval !== null) {\n      clearInterval(durationInterval);\n    }\n    if (isRecording.value) {\n      recordingService.stopRecording().catch(console.error);\n    }\n  });\n  \n  return {\n    isRecording,\n    recordingMode,\n    recordingDuration,\n    recordingFileSize,\n    formattedDuration,\n    formattedFileSize,\n    startRecording,\n    stopRecording\n  };\n}\n\n// useDrawing.ts - Composable for drawing functionality\nimport { ref, onMounted, onUnmounted } from 'vue';\nimport { DrawingCanvas } from '../services/drawing-canvas';\n\nexport function useDrawing(canvasRef: any) {\n  const currentTool = ref<'pencil' | 'highlighter' | 'eraser'>('pencil');\n  const currentColor = ref('#FF0000');\n  const canUndo = ref(false);\n  const canRedo = ref(false);\n  let drawingCanvas: DrawingCanvas | null = null;\n  \n  onMounted(() => {\n    if (canvasRef.value) {\n      drawingCanvas = new DrawingCanvas(canvasRef.value);\n      drawingCanvas.setTool(currentTool.value);\n      drawingCanvas.setColor(currentColor.value);\n      \n      // Update undo/redo state\n      drawingCanvas.onStateChange = (state) => {\n        canUndo.value = state.canUndo;\n        canRedo.value = state.canRedo;\n      };\n    }\n  });\n  \n  function setTool(tool: 'pencil' | 'highlighter' | 'eraser') {\n    currentTool.value = tool;\n    drawingCanvas?.setTool(tool);\n  }\n  \n  function setColor(color: string) {\n    currentColor.value = color;\n    drawingCanvas?.setColor(color);\n  }\n  \n  function undo() {\n    drawingCanvas?.undo();\n  }\n  \n  function redo() {\n    drawingCanvas?.redo();\n  }\n  \n  function clear() {\n    drawingCanvas?.clear();\n  }\n  \n  onUnmounted(() => {\n    drawingCanvas?.dispose();\n    drawingCanvas = null;\n  });\n  \n  return {\n    currentTool,\n    currentColor,\n    canUndo,\n    canRedo,\n    setTool,\n    setColor,\n    undo,\n    redo,\n    clear\n  };\n}\n```",
        "testStrategy": "Test composable hooks by creating test components that use them. Verify that state management works correctly across components. Test lifecycle hooks by mounting and unmounting components. Test error handling by simulating error conditions. Verify that composables properly clean up resources when components are unmounted.",
        "priority": "medium",
        "dependencies": [
          2,
          6,
          7
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Create Extension Packaging and Distribution Configuration",
        "description": "Set up the build and packaging process for distributing the extension to Chrome Web Store and Firefox Add-ons.",
        "details": "1. Configure WXT for production builds\n2. Set up browser-specific manifest configurations\n3. Create build scripts for Chrome and Firefox packages\n4. Implement version management\n5. Add extension icons and promotional materials\n\nExample implementation:\n```ts\n// wxt.config.ts\nimport { defineConfig } from 'wxt';\nimport { version } from './package.json';\n\nexport default defineConfig({\n  manifest: {\n    name: '录屏助手',\n    description: '一款功能强大的浏览器录屏工具，支持标注和编辑',\n    version,\n    permissions: [\n      'activeTab',\n      'storage',\n      'unlimitedStorage'\n    ],\n    host_permissions: [\n      '<all_urls>'\n    ],\n    icons: {\n      '16': 'assets/icons/icon-16.png',\n      '48': 'assets/icons/icon-48.png',\n      '128': 'assets/icons/icon-128.png'\n    },\n    action: {\n      default_popup: 'popup/index.html',\n      default_icon: {\n        '16': 'assets/icons/icon-16.png',\n        '48': 'assets/icons/icon-48.png',\n        '128': 'assets/icons/icon-128.png'\n      }\n    },\n    background: {\n      service_worker: 'background/index.ts'\n    },\n    content_scripts: [\n      {\n        matches: ['<all_urls>'],\n        js: ['content/index.ts']\n      }\n    ],\n    web_accessible_resources: [\n      {\n        resources: ['assets/*'],\n        matches: ['<all_urls>']\n      }\n    ],\n    commands: {\n      'stop-recording': {\n        suggested_key: {\n          default: 'Ctrl+Shift+E',\n          mac: 'Command+Shift+E'\n        },\n        description: '结束录制'\n      }\n    }\n  },\n  // Browser-specific overrides\n  overrides: {\n    chrome: {\n      manifest: {\n        // Chrome-specific manifest options\n      }\n    },\n    firefox: {\n      manifest: {\n        // Firefox-specific manifest options\n        browser_specific_settings: {\n          gecko: {\n            id: 'screen-recorder@example.com',\n            strict_min_version: '109.0'\n          }\n        }\n      }\n    }\n  },\n  // Build configuration\n  build: {\n    target: 'browser-extension',\n    outDir: 'dist',\n    emptyOutDir: true,\n    sourcemap: false,\n    minify: true\n  },\n  // Dev server configuration\n  dev: {\n    reloadCommand: 'reload-extension',\n    startCommand: 'start-extension'\n  }\n});\n\n// package.json scripts\n{\n  \"scripts\": {\n    \"dev\": \"wxt\",\n    \"build\": \"wxt build\",\n    \"build:chrome\": \"wxt build --browser chrome\",\n    \"build:firefox\": \"wxt build --browser firefox\",\n    \"zip\": \"node scripts/zip-packages.js\",\n    \"release\": \"npm run build && npm run zip\"\n  }\n}\n\n// scripts/zip-packages.js\nconst fs = require('fs');\nconst path = require('path');\nconst archiver = require('archiver');\nconst { version } = require('../package.json');\n\n// Create zip files for Chrome and Firefox\nfunction createZip(browser) {\n  const output = fs.createWriteStream(path.join(__dirname, `../dist/screen-recorder-${browser}-${version}.zip`));\n  const archive = archiver('zip', { zlib: { level: 9 } });\n  \n  output.on('close', () => {\n    console.log(`${browser} package created: ${archive.pointer()} bytes`);\n  });\n  \n  archive.on('error', (err) => {\n    throw err;\n  });\n  \n  archive.pipe(output);\n  archive.directory(path.join(__dirname, `../dist/${browser}`), false);\n  archive.finalize();\n}\n\ncreateZip('chrome');\ncreateZip('firefox');\n```",
        "testStrategy": "Test packaging by building the extension for both Chrome and Firefox. Verify that the generated packages have the correct structure and manifest files. Test installation by installing the packaged extensions in Chrome and Firefox. Verify that all permissions are correctly requested and the extension works as expected after installation.",
        "priority": "low",
        "dependencies": [
          1,
          13
        ],
        "status": "done",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-06-28T16:55:44.700Z",
      "updated": "2025-06-28T18:00:20.113Z",
      "description": "Tasks for master context"
    }
  }
}